\label{index_md_README}%
\Hypertarget{index_md_README}%
 \hypertarget{index_autotoc_md1}{}\doxysection{Installation}\label{index_autotoc_md1}
This library is header-\/only, so you can simply link files in \href{./src}{\texttt{ src}}.\hypertarget{index_autotoc_md2}{}\doxysubsection{Requirements}\label{index_autotoc_md2}
The only requirement is to have at least {\ttfamily c++2a}. Parallelism is implemented using {\ttfamily Open\+MP}, although the pure {\ttfamily MPI} implementation is more efficient right now.\hypertarget{index_autotoc_md3}{}\doxysection{Documentation}\label{index_autotoc_md3}
The code is documented using {\ttfamily doxygen}. Documentation is present in \href{./docs/}{\texttt{ docs/}} and is also hosted at \href{https://jolatechno.github.io/QuIDS/}{\texttt{ jolatechno.\+github.\+io/\+Qu\+IDS/}}.\hypertarget{index_autotoc_md4}{}\doxysection{Usage}\label{index_autotoc_md4}
Some rules that can be used directly, or understood as examples are implemented in \href{./src/rules}{\texttt{ src/rules}}.

Objects are represented by a simple begin and end pointer. Their exist two kind of interfaces for implementing a unitary transformation.

{\ttfamily modifiers} and {\ttfamily rules} are applied using the {\ttfamily quids\+::simulate(...)} function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}src/quids.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) \{}
\DoxyCodeLine{    \textcolor{comment}{/* variables*/}}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a60a676728450b703f98f219a0ee7e5f2}{quids::it\_t}} next\_state, state;}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a2f3cfcb2f4d55d58993493426aafb2fe}{quids::sy\_it\_t}} symbolic\_iteration;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* initializing the state */}}
\DoxyCodeLine{    state.append(object\_begin, object\_end);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* applying a modifier */}}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a0cd589223d6f94d98d0d52849bfcd76a}{quids::simulate}}(state, my\_modifier);}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a0cd589223d6f94d98d0d52849bfcd76a}{quids::simulate}}(state, [](\textcolor{keywordtype}{char} *parent\_begin, \textcolor{keywordtype}{char} *parent\_end, std::complex<PROBA\_TYPE> \&mag) \{}
\DoxyCodeLine{            \textcolor{comment}{/* using lambda-\/expressions */}}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* applying a rule */}}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a62455c8f5240a575676aace3a25dfae3}{quids::rule\_t}} *rule = \textcolor{keyword}{new} my\_rule(\textcolor{comment}{/*...*/});}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a0cd589223d6f94d98d0d52849bfcd76a}{quids::simulate}}(state, rule, next\_state, symbolic\_iteration);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* "{}next\_state"{} now holds an application of "{}rule"{} on "{}state"{} */}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md5}{}\doxysubsection{MPI support}\label{index_autotoc_md5}
Simulations can also be done across nodes. For that, you\textquotesingle{}ll need to replace {\ttfamily quids\+::sy\+\_\+it} and {\ttfamily \mbox{\hyperlink{namespacequids_a60a676728450b703f98f219a0ee7e5f2}{quids\+::it\+\_\+t}}} respectivly by {\ttfamily quids\+::mpi\+::mpi\+\_\+sy\+\_\+it} and {\ttfamily \mbox{\hyperlink{namespacequids_1_1mpi_a35f6cb8275fdb46ab6042a3e4bd799ba}{quids\+::mpi\+::mpi\+\_\+it\+\_\+t}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}src/quids\_mpi.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) \{}
\DoxyCodeLine{    \textcolor{comment}{/* MPI initialization */}}
\DoxyCodeLine{    \textcolor{keywordtype}{int} size, rank, provided;}
\DoxyCodeLine{    MPI\_Init\_thread(\&argc, \&argv, MPI\_THREAD\_SERIALIZED, \&provided);}
\DoxyCodeLine{    \textcolor{keywordflow}{if}(provided < MPI\_THREAD\_SERIALIZED) \{}
\DoxyCodeLine{        printf(\textcolor{stringliteral}{"{}The threading support level is lesser than that demanded.\(\backslash\)n"{}});}
\DoxyCodeLine{        MPI\_Abort(MPI\_COMM\_WORLD, EXIT\_FAILURE);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* variables*/}}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_1_1mpi_a35f6cb8275fdb46ab6042a3e4bd799ba}{quids::mpi::mpi\_it\_t}} next\_state, state;}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_1_1mpi_a3e3b2dbb59ff2b0f9b997fb9bf196cc8}{quids::mpi::mpi\_sy\_it\_t}} symbolic\_iteration;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* initializing the state */}}
\DoxyCodeLine{    state.append(object\_begin, object\_end);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* applying a modifier */}}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a0cd589223d6f94d98d0d52849bfcd76a}{quids::simulate}}(state, my\_modifier);}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a0cd589223d6f94d98d0d52849bfcd76a}{quids::simulate}}(state, [](\textcolor{keywordtype}{char} *parent\_begin, \textcolor{keywordtype}{char} *parent\_end, std::complex<PROBA\_TYPE> \&mag) \{}
\DoxyCodeLine{            \textcolor{comment}{/* using lambda-\/expressions */}}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* applying a rule */}}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_a62455c8f5240a575676aace3a25dfae3}{quids::rule\_t}} *rule = \textcolor{keyword}{new} my\_rule(\textcolor{comment}{/*...*/});}
\DoxyCodeLine{    \mbox{\hyperlink{namespacequids_1_1mpi_ab589d2622e28bfe6e3522a103c841450}{quids::mpi::simulate}}(state, rule, next\_state, symbolic\_iteration, MPI\_COMM\_WORLD);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* "{}next\_state"{} now holds an application of "{}rule"{} on "{}state"{} */}}
\DoxyCodeLine{}
\DoxyCodeLine{    MPI\_Finalize();}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md6}{}\doxysubsection{Modifiers}\label{index_autotoc_md6}
A {\ttfamily modifier} is a simple functions that takes a objects, and modify it in place, while keep its size unchanged.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} my\_modifier(\textcolor{keywordtype}{char} *parent\_begin, \textcolor{keywordtype}{char} *parent\_end, std::complex<PROBA\_TYPE> \&mag) \{}
\DoxyCodeLine{    \textcolor{comment}{// modify the object...}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md7}{}\doxysubsection{Rules}\label{index_autotoc_md7}
A {\ttfamily rule} is a simple class, implementing 2 functions (with a third being optional).


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }my\_rule : \textcolor{keyword}{public} \mbox{\hyperlink{namespacequids_a62455c8f5240a575676aace3a25dfae3}{quids::rule\_t}} \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{    my\_rule() \{\};}
\DoxyCodeLine{    \textcolor{keyword}{inline} \textcolor{keywordtype}{void} get\_num\_child(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end, }
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} \&num\_child, \textcolor{keywordtype}{size\_t} \&max\_child\_size) \textcolor{keyword}{const override};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{inline} \textcolor{keywordtype}{void} populate\_child(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end,}
\DoxyCodeLine{        \textcolor{keywordtype}{char}* \textcolor{keyword}{const} child\_begin, uint32\_t \textcolor{keyword}{const} child\_id,}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} \&size, std::complex<PROBA\_TYPE> \&mag) \textcolor{keyword}{const override};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{inline} \textcolor{keywordtype}{void} populate\_child\_simple(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end,}
\DoxyCodeLine{        \textcolor{keywordtype}{char}* \textcolor{keyword}{const} child\_begin, uint32\_t \textcolor{keyword}{const} child\_id) \textcolor{keyword}{const}; \textcolor{comment}{// optional}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{inline} \textcolor{keywordtype}{size\_t} hasher(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end) \textcolor{keyword}{const}; \textcolor{comment}{// optional}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The first function, {\ttfamily get\+\_\+num\+\_\+child(...)}, finds the number of objects created through the unitary transform by a given objects. It also gives an upper-\/bound to the size of those objects.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} my\_rule::get\_num\_child(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end,}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} \&num\_child, \textcolor{keywordtype}{size\_t} \&max\_child\_size)\textcolor{keyword}{ const override}}
\DoxyCodeLine{\textcolor{keyword}{}\{}
\DoxyCodeLine{    \textcolor{comment}{// do stuff...}}
\DoxyCodeLine{    num\_child = actual\_num\_child;}
\DoxyCodeLine{    max\_child\_size = actual\_max\_child\_size;}
\DoxyCodeLine{\}}

\end{DoxyCode}


The second function, {\ttfamily populate\+\_\+child(...)}, simply \char`\"{}populate\char`\"{} (create) an object from its parent, while also modifying its magnitude according to the unitary transformation (the starting magnitude is the parent magnitude).

Note that {\ttfamily child\+\_\+id} is a number from {\ttfamily 0} to {\ttfamily num\+\_\+child}, and simply identify \char`\"{}child\char`\"{} amoung its \char`\"{}siblings\char`\"{} (objects with the same \char`\"{}parent\char`\"{}).


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} populate\_child(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end,}
\DoxyCodeLine{    \textcolor{keywordtype}{char}* \textcolor{keyword}{const} child\_begin, uint32\_t \textcolor{keyword}{const} child\_id,}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} \&size, std::complex<PROBA\_TYPE> \&mag)\textcolor{keyword}{ const override}}
\DoxyCodeLine{\textcolor{keyword}{}\{}
\DoxyCodeLine{    \textcolor{comment}{// modify mag...}}
\DoxyCodeLine{    \textcolor{comment}{// populate the child, starting at child\_begin}}
\DoxyCodeLine{    size = actual\_child\_size;}
\DoxyCodeLine{\}}

\end{DoxyCode}


The third function is {\ttfamily populate\+\_\+child\+\_\+simple(...)} which is simply a copy of {\ttfamily populate\+\_\+child(...)} that can skip the computation of the magnitude and the size of the child objects. If not provided the default implementation relize on {\ttfamily populate\+\_\+child(...)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} populate\_child\_simple(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end,}
\DoxyCodeLine{    \textcolor{keywordtype}{char}* \textcolor{keyword}{const} child\_begin, uint32\_t \textcolor{keyword}{const} child\_id)\textcolor{keyword}{ const }\{ \textcolor{comment}{//can be overwritten}}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} size\_placeholder;}
\DoxyCodeLine{        \mbox{\hyperlink{namespacequids_a13a066a7f98435d1c84f2318439d4f0b}{mag\_t}} mag\_placeholder;}
\DoxyCodeLine{        populate\_child(parent\_begin, parent\_end, child\_begin, child\_id,}
\DoxyCodeLine{            size\_placeholder, mag\_placeholder);}
\DoxyCodeLine{\}}

\end{DoxyCode}


The last function is a hasher for objects. If not specified, the whole memory buffer will simply be hashed. A hasher NEEDS to be provided if objects that are equal can be represented by different objects. The default implementation is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{size\_t} my\_rule::hasher(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *parent\_end)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} std::hash<std::string\_view>()(}
\DoxyCodeLine{        std::string\_view(parent\_begin, std::distance(parent\_begin, parent\_end)));}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md8}{}\doxysubsection{Interaction with the different classes}\label{index_autotoc_md8}
We can see that a quantum state is represented by a specific {\ttfamily iteration} class, and a {\ttfamily symbolic\+\_\+iteration} is generated when applying a unitary transformation on a state. We interact with those classes (modify or read a state, ect...) through public member functions and variables, which will be shortly documented bellow, as they are vital to building a {\bfseries{usefull}} program using {\ttfamily Qu\+IDS}.\hypertarget{index_autotoc_md9}{}\doxysubsubsection{Symbolic iteration}\label{index_autotoc_md9}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{class }symbolic\_iteration \mbox{\hyperlink{namespacequids_a2f3cfcb2f4d55d58993493426aafb2fe}{sy\_it\_t}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }symbolic\_iteration \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} num\_object = 0;}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} num\_object\_after\_interferences = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{    symbolic\_iteration() \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{    \textcolor{comment}{/*...*/}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The {\ttfamily symbolic\+\_\+iteration} class (or {\ttfamily sy\+\_\+it\+\_\+t} type) only has a basic constructor, as it is only ment to be used internaly.

Member variables are\+:
\begin{DoxyItemize}
\item {\ttfamily num\+\_\+object} \+: Number of objects generated at symbolic iteration (before interferences and truncation).
\item {\ttfamily num\+\_\+object\+\_\+after\+\_\+interferences} \+: Number of objects after eliminating duplicates (so called \char`\"{}interferences\char`\"{}), but before truncation.
\end{DoxyItemize}\hypertarget{index_autotoc_md10}{}\doxysubsubsection{Iteration}\label{index_autotoc_md10}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{class }iteration \mbox{\hyperlink{namespacequids_a60a676728450b703f98f219a0ee7e5f2}{it\_t}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }iteration \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} num\_object = 0;}
\DoxyCodeLine{    PROBA\_TYPE total\_proba = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{    iteration();}
\DoxyCodeLine{    iteration(\textcolor{keywordtype}{char}* object\_begin\_, \textcolor{keywordtype}{char}* object\_end\_);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} append(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *object\_begin\_, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *object\_end\_, std::complex<PROBA\_TYPE> \textcolor{keyword}{const} mag=1);}
\DoxyCodeLine{    \textcolor{keywordtype}{void} pop(uint n=1, \textcolor{keywordtype}{bool} normalize\_=\textcolor{keyword}{true});}
\DoxyCodeLine{    \textcolor{keywordtype}{void} get\_object(\textcolor{keywordtype}{size\_t} \textcolor{keyword}{const} object\_id, \textcolor{keywordtype}{char} *\& object\_begin, \textcolor{keywordtype}{size\_t} \&object\_size, std::complex<PROBA\_TYPE> *\&mag);}
\DoxyCodeLine{    \textcolor{keywordtype}{void} get\_object(\textcolor{keywordtype}{size\_t} \textcolor{keyword}{const} object\_id, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *\& object\_begin, \textcolor{keywordtype}{size\_t} \&object\_size, std::complex<PROBA\_TYPE> \&mag) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{    T average\_value(std::function<T(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *object\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *object\_end)> \textcolor{keyword}{const} \&observable) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{    \textcolor{comment}{/*...*/}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The {\ttfamily iteration} class (or {\ttfamily it\+\_\+t} type) has two constructors, a basic one, and one that simply takes a starting object and append it to the state with probability one.

Member functions are\+:
\begin{DoxyItemize}
\item {\ttfamily append(...)} \+: Append an object to the state, with a give magnitude (default = 1).
\item {\ttfamily pop(...)} \+: Remove the {\ttfamily n} last objects, and normalze (if {\ttfamily normalize\+\_\+} is {\ttfamily true}).
\item {\ttfamily get\+\_\+object(...)} \+: Allows to read (either as constant or not) an objects and its magnitude, with a given {\ttfamily object\+\_\+id} between 0 and {\ttfamily num\+\_\+object}. Note that the non-\/constant function takes pointers for {\ttfamily mag}.
\item {\ttfamily average\+\_\+value(...)} \+: Compute the average value of an observable (a function) of any type (that can be added, initialized by {\ttfamily T x = 0}, and multiplied by an object of type {\ttfamily PROBA\+\_\+\+TYPE}).
\end{DoxyItemize}

Member variables are\+:
\begin{DoxyItemize}
\item {\ttfamily num\+\_\+object} \+: Number of object describing this state currently in superposition.
\item {\ttfamily total\+\_\+proba} \+: total probability held by this state before normalizing it (so after truncation).
\end{DoxyItemize}\hypertarget{index_autotoc_md11}{}\doxysubsubsection{MPI symbolic iteration}\label{index_autotoc_md11}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{class }mpi\_symbolic\_iteration \mbox{\hyperlink{namespacequids_1_1mpi_a3e3b2dbb59ff2b0f9b997fb9bf196cc8}{mpi\_sy\_it\_t}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }mpi\_symbolic\_iteration : \textcolor{keyword}{public} \mbox{\hyperlink{classquids_1_1symbolic__iteration}{quids::symbolic\_iteration}} \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} get\_total\_num\_object(MPI\_Comm communicator) \textcolor{keyword}{const};}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} get\_total\_num\_object\_after\_interferences(MPI\_Comm communicator) \textcolor{keyword}{const};}
\DoxyCodeLine{    mpi\_symbolic\_iteration() \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{    \textcolor{comment}{/*...*/}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The {\ttfamily mpi\+\_\+symbolic\+\_\+iteration} class (or {\ttfamily mpi\+\_\+sy\+\_\+it\+\_\+t} type) can be considered as exactly equivalent to the {\ttfamily symbolic\+\_\+iteration} class (or {\ttfamily sy\+\_\+it\+\_\+t} type).

The two added member functions are\+:
\begin{DoxyItemize}
\item {\ttfamily get\+\_\+total\+\_\+num\+\_\+object(...)} \+: Get the total number of object at symbolic iteration accross all nodes.
\item {\ttfamily get\+\_\+total\+\_\+num\+\_\+object\+\_\+after\+\_\+interferences(...)} \+: Get the total number of object at symbolic iteration, after interferences but before truncation, accross all nodes.
\end{DoxyItemize}\hypertarget{index_autotoc_md12}{}\doxysubsubsection{MPI iteration}\label{index_autotoc_md12}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{class }mpi\_iteration \mbox{\hyperlink{namespacequids_1_1mpi_a35f6cb8275fdb46ab6042a3e4bd799ba}{mpi\_it\_t}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }mpi\_iteration : \textcolor{keyword}{public} \mbox{\hyperlink{classquids_1_1iteration}{quids::iteration}} \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{    PROBA\_TYPE node\_total\_proba = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{    mpi\_iteration() \{\}}
\DoxyCodeLine{    mpi\_iteration(\textcolor{keywordtype}{char}* object\_begin\_, \textcolor{keywordtype}{char}* object\_end\_) : \mbox{\hyperlink{namespacequids}{quids}}::iteration(object\_begin\_, object\_end\_) \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} equalize(MPI\_Comm communicator);}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} get\_total\_num\_object(MPI\_Comm communicator) \textcolor{keyword}{const};}
\DoxyCodeLine{    \textcolor{keywordtype}{void} send\_objects(\textcolor{keywordtype}{size\_t} num\_object\_sent, \textcolor{keywordtype}{int} node, MPI\_Comm communicator);}
\DoxyCodeLine{    \textcolor{keywordtype}{void} receive\_objects(\textcolor{keywordtype}{int} node, MPI\_Comm communicator);}
\DoxyCodeLine{    \textcolor{keywordtype}{void} distribute\_objects(MPI\_Comm comunicator, \textcolor{keywordtype}{int} node\_id);}
\DoxyCodeLine{    \textcolor{keywordtype}{void} gather\_objects(MPI\_Comm comunicator, \textcolor{keywordtype}{int} node\_id);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{    T \mbox{\hyperlink{classquids_1_1iteration_a605ea87c36fba513f9ced985a56a14f0}{average\_value}}(std::function<T(\textcolor{keywordtype}{char} \textcolor{keyword}{const} *object\_begin, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *object\_end)> \textcolor{keyword}{const} \&observable, MPI\_Comm communicator) \textcolor{keyword}{const}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{    \textcolor{comment}{/*...*/}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The {\ttfamily mpi\+\_\+iteration} class (or {\ttfamily mpi\+\_\+it\+\_\+t} type) inehrits all the public memeber functions and varibale of the {\ttfamily iteration} class (or {\ttfamily it\+\_\+t} type), and shares similar constructors.

The additional member functions are\+:
\begin{DoxyItemize}
\item {\ttfamily equalize(...)} \+: Does its best at equalizing the number of object on each node. Will only equalize among pair (in hopefully the optimal pair-\/arangment), so it\textquotesingle{}s up to you to check if the objects are equally shared among nodes, as some spetial cases can\textquotesingle{}t be equalized well by this algorithm. {\ttfamily normalize(\+MPI\+\_\+\+Comm ...)} should be after {\ttfamily equalize(...)} at the end to compute {\ttfamily node\+\_\+total\+\_\+proba}.
\item {\ttfamily get\+\_\+total\+\_\+num\+\_\+object(...)} \+: Get the total number of object accross all nodes.
\item {\ttfamily send\+\_\+objects(...)} \+: Send a given number of object to a node, and {\ttfamily pop} them of the sending one. {\ttfamily normalize(\+MPI\+\_\+\+Comm ...)} should be after {\ttfamily send\+\_\+objects(...)} at the end to compute {\ttfamily node\+\_\+total\+\_\+proba}.
\item {\ttfamily receive\+\_\+objects(...)} \+: Receiving end of the {\ttfamily send\+\_\+objects(...)} function. {\ttfamily normalize(\+MPI\+\_\+\+Comm ...)} should be after {\ttfamily receive\+\_\+objects(...)} at the end to compute {\ttfamily node\+\_\+total\+\_\+proba}.
\item {\ttfamily distribute\+\_\+objects(..)} \+: Distribute objects that are located on a single node of id {\ttfamily node\+\_\+id} (0 if not specified) equally on all other nodes. {\ttfamily normalize(\+MPI\+\_\+\+Comm ...)} should be after {\ttfamily distribute\+\_\+objects(...)} at the end to compute {\ttfamily node\+\_\+total\+\_\+proba}.
\item {\ttfamily gather\+\_\+objects(...)} \+: Gather objects on all nodes to the node of id {\ttfamily node\+\_\+id} (0 if not specified). If all objects can\textquotesingle{}t fit on the memory of this node, the function will throw a {\ttfamily bad alloc} error as the behavior is undefined. {\ttfamily node\+\_\+total\+\_\+proba} is calculated at the end as it doesn\textquotesingle{}t require a calling {\ttfamily normalize(\+MPI\+\_\+\+Comm ...)}.
\item {\ttfamily average\+\_\+value(...)} \+: equiavlent to the normal {\ttfamily iteration} member function, but for the whole distributed wave function ({\bfseries{note that calling}} {\ttfamily average\+\_\+value(...)} {\bfseries{without an}} {\ttfamily MPI\+\_\+\+Comm} {\bfseries{will return a local average value for retrocompatibility with the basic}} {\ttfamily iteration} {\bfseries{class}}).
\end{DoxyItemize}

{\ttfamily node\+\_\+total\+\_\+proba} is the only additional member variable, and is the proportion of total probability that is held by a given node.\hypertarget{index_autotoc_md13}{}\doxysubsection{Global parameters and pre-\/processor flags}\label{index_autotoc_md13}
In addition to classes, some global parameters are used to modify the behaviour of the simulation.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifndef PROBA\_TYPE}}
\DoxyCodeLine{\textcolor{preprocessor}{    \#define PROBA\_TYPE double}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifndef HASH\_MAP\_OVERHEAD}}
\DoxyCodeLine{\textcolor{preprocessor}{    \#define HASH\_MAP\_OVERHEAD 1.5}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{/* other default-\/value flags */}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespacequids}{quids}} \{}
\DoxyCodeLine{    PROBA\_TYPE \mbox{\hyperlink{namespacequids_ae6148553f287fa7c670cc8d0a729fe8d}{tolerance}} = TOLERANCE;}
\DoxyCodeLine{    \textcolor{keywordtype}{float} \mbox{\hyperlink{namespacequids_acf286be928cefbb5ad9e672e1999de1b}{safety\_margin}} = SAFETY\_MARGIN;}
\DoxyCodeLine{    \textcolor{keywordtype}{int} \mbox{\hyperlink{namespacequids_a967bbc4ed348a75e24789554a64f8d62}{load\_balancing\_bucket\_per\_thread}} = LOAD\_BALANCING\_BUCKET\_PER\_THREAD;}
\DoxyCodeLine{\textcolor{preprocessor}{    \#ifdef SIMPLE\_TRUNCATION}}
\DoxyCodeLine{        \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacequids_af08ec7fda63cfb6d458ad3bb10b31e4d}{simple\_truncation}} = \textcolor{keyword}{true};}
\DoxyCodeLine{\textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{        \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacequids_af08ec7fda63cfb6d458ad3bb10b31e4d}{simple\_truncation}} = \textcolor{keyword}{false};}
\DoxyCodeLine{\textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{namespace }mpi \{}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{namespacequids_1_1mpi_a31fde7b46759670da2fe0f6b3731f5c0}{min\_equalize\_size}} = MIN\_EQUALIZE\_SIZE;}
\DoxyCodeLine{        \textcolor{keywordtype}{float} \mbox{\hyperlink{namespacequids_1_1mpi_ab5de5240ccfc019063996bdc48e7a20b}{equalize\_inbalance}} = EQUALIZE\_INBALANCE;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{/* ... */}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{namespace }utils \{}
\DoxyCodeLine{        \textcolor{keywordtype}{float} \mbox{\hyperlink{namespacequids_1_1utils_a90041f6130e71de649d376e77040893d}{upsize\_policy}} = UPSIZE\_POLICY;}
\DoxyCodeLine{        \textcolor{keywordtype}{float} \mbox{\hyperlink{namespacequids_1_1utils_a1030df3ee43b5a7caf2fcc8e4e68e281}{downsize\_policy}} = DOWNSIZE\_POLICY;}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{namespacequids_1_1utils_af6008a56b61821492cabc5d71d351938}{min\_vector\_size}} = MIN\_VECTOR\_SIZE;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{/* ... */}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* ... */}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md14}{}\doxysubsection{Pre-\/processor flags}\label{index_autotoc_md14}
\hypertarget{index_autotoc_md15}{}\doxysubsubsection{proba. type}\label{index_autotoc_md15}
The {\ttfamily PROBA\+\_\+\+TYPE} flag is used to change the type used to represent probabilities and magnitude in the program. The default is {\ttfamily double} for a high enough precision, but other float type could be used to either get more precision or less memory/execution time cost.\hypertarget{index_autotoc_md16}{}\doxysubsubsection{hash map overhead}\label{index_autotoc_md16}
The {\ttfamily HASH\+\_\+\+MAP\+\_\+\+OVERHEAD} flag represent the overhead per element of the hashmap (of type {\ttfamily robin\+\_\+hood\+::unordered\+\_\+map}, default is set to {\ttfamily 1.\+7} which has been determined through experiments).\hypertarget{index_autotoc_md17}{}\doxysubsection{Global variables}\label{index_autotoc_md17}
The default value of any of those variable can be altered at compilation, by passing an uppercase flag with the same name as the desired variable.\hypertarget{index_autotoc_md18}{}\doxysubsubsection{tolerance}\label{index_autotoc_md18}
{\ttfamily tolerance} represents the minimum probability considered non-\/zero (default is {\ttfamily 1e-\/30}, to compensate for numerical errors).\hypertarget{index_autotoc_md19}{}\doxysubsubsection{safety margin}\label{index_autotoc_md19}
{\ttfamily safety\+\_\+margin} represents the target proportion of memory to keep free (default is {\ttfamily 0.\+1} for 10\%).\hypertarget{index_autotoc_md20}{}\doxysubsubsection{simple truncation}\label{index_autotoc_md20}
{\ttfamily simple\+\_\+truncation} is a {\ttfamily bool} variable (default is {\ttfamily false}, but can be set to {\ttfamily true} by compilling with the {\ttfamily SIMPLE\+\_\+\+TRUNCATION} flag). If {\ttfamily simple\+\_\+truncation} is {\ttfamily true}, then truncation simply consist in selecting the n highest probability objects. Otherwise object are selected with some probabilistic aspect, with the probability of keeping an object being proportional to the probability of each object.

Probabilistic selctions cost a bit of time and of accuracy, with some gain in representation through an analog sampling process to a quantum Monte-\/\+Carlo algorithm.\hypertarget{index_autotoc_md21}{}\doxysubsubsection{load balancing bucket per thread}\label{index_autotoc_md21}
{\ttfamily load\+\_\+balancing\+\_\+bucket\+\_\+per\+\_\+thread} represent the number of partition par thread (or MPI node), which allows load balancing by then having a variable number of partition per thread according to each partition\textquotesingle{}s size.

{\ttfamily load\+\_\+balancing\+\_\+bucket\+\_\+per\+\_\+thread} has a default of {\ttfamily 8}.\hypertarget{index_autotoc_md22}{}\doxysubsection{MPI global variables}\label{index_autotoc_md22}
\hypertarget{index_autotoc_md23}{}\doxysubsubsection{minimum equalize size and equalize imbalance.}\label{index_autotoc_md23}
{\ttfamily mpi\+::min\+\_\+equalize\+\_\+size} represents the minimum per node average size required to automaticly call {\ttfamily equalize(...)} after a call to {\ttfamily quids\+::mpi\+::simulate(...)}.

If this first condition is met, {\ttfamily equalize(...)} if the maximum relative imbalance in the number of object accross the nodes is greater than {\ttfamily mpi\+::equalize\+\_\+imablance}.

{\ttfamily mpi\+::min\+\_\+equalize\+\_\+size} is equal to {\ttfamily 1000} by default, and {\ttfamily mpi\+::equalize\+\_\+imablance} has a default of {\ttfamily 0.\+2}.\hypertarget{index_autotoc_md24}{}\doxysubsection{Utils global variables}\label{index_autotoc_md24}
\hypertarget{index_autotoc_md25}{}\doxysubsubsection{min vector size}\label{index_autotoc_md25}
{\ttfamily utils\+::min\+\_\+vector\+\_\+size} represent the minimum size of any vector (the default is {\ttfamily 100000}).\hypertarget{index_autotoc_md26}{}\doxysubsubsection{upsize policy}\label{index_autotoc_md26}
{\ttfamily utils\+::upsize\+\_\+policy} represent the multiplier applied when upsizing a vector (the default is {\ttfamily 1.\+1}). It avoid frequent upsizing by giving a small margin.\hypertarget{index_autotoc_md27}{}\doxysubsubsection{downsize policy}\label{index_autotoc_md27}
{\ttfamily utils\+::downsize\+\_\+policy} reprensent the threshold multiplier to downsize a vector (the default is {\ttfamily 0.\+85}). A vector won\textquotesingle{}t be downsized until the requested size is smaller than this ultiplier times the capacity of the given vector.

{\bfseries{!! this multiplier should always be smaller than the inverse of upsize\+\_\+policy to avoid upsizing-\/downsizing loop !!}} 