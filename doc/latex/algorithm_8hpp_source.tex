\hypertarget{algorithm_8hpp_source}{}\doxysection{algorithm.\+hpp}
\label{algorithm_8hpp_source}\index{/home/joseph/Documents/projets/programing/cpp/Quantum-\/graph-\/simulation/src/QuIDS/src/utils/algorithm.hpp@{/home/joseph/Documents/projets/programing/cpp/Quantum-\/graph-\/simulation/src/QuIDS/src/utils/algorithm.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4 }
\DoxyCodeLine{6 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacequids_1_1utils}{quids::utils}} \{}
\DoxyCodeLine{7     }
\DoxyCodeLine{8     \textcolor{comment}{/*}}
\DoxyCodeLine{9 \textcolor{comment}{    closest power of two}}
\DoxyCodeLine{10 \textcolor{comment}{    */}}
\DoxyCodeLine{11     \textcolor{keywordtype}{int} nearest\_power\_of\_two(\textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{12         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1;; i *= 2)}
\DoxyCodeLine{13             \textcolor{keywordflow}{if} (i >= n)}
\DoxyCodeLine{14                 \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{15     \}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17     \textcolor{keywordtype}{int} log\_2\_upper\_bound(\textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{18         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1;; ++i)}
\DoxyCodeLine{19             \textcolor{keywordflow}{if} (n >> i == 0)}
\DoxyCodeLine{20                 \textcolor{keywordflow}{return} i -\/ 1;}
\DoxyCodeLine{21     \}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23     \textcolor{comment}{/* }}
\DoxyCodeLine{24 \textcolor{comment}{    parallel iota}}
\DoxyCodeLine{25 \textcolor{comment}{    */}}
\DoxyCodeLine{26     \textcolor{keyword}{template} <\textcolor{keyword}{class} iteratorType, \textcolor{keyword}{class} valueType>}
\DoxyCodeLine{27     \textcolor{keywordtype}{void} parallel\_iota(iteratorType begin, iteratorType end, \textcolor{keyword}{const} valueType value\_begin) \{}
\DoxyCodeLine{28         \textcolor{keywordtype}{size\_t} distance = std::distance(begin, end);}
\DoxyCodeLine{29 }
\DoxyCodeLine{30         \textcolor{keywordflow}{if} (value\_begin == 0) \{}
\DoxyCodeLine{31 \textcolor{preprocessor}{            \#pragma omp parallel for }}
\DoxyCodeLine{32             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < distance; ++i)}
\DoxyCodeLine{33                 begin[i] = i;}
\DoxyCodeLine{34         \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{35 \textcolor{preprocessor}{            \#pragma omp parallel for }}
\DoxyCodeLine{36             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < distance; ++i)}
\DoxyCodeLine{37                 begin[i] = value\_begin + i;}
\DoxyCodeLine{38     \}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40     \textcolor{comment}{/*}}
\DoxyCodeLine{41 \textcolor{comment}{    function to partition into n section}}
\DoxyCodeLine{42 \textcolor{comment}{    */}}
\DoxyCodeLine{43     \textcolor{keyword}{template} <\textcolor{keyword}{class} \textcolor{keywordtype}{id}IteratorType, \textcolor{keyword}{class} countIteratorType, \textcolor{keyword}{class} functionType>}
\DoxyCodeLine{44     \textcolor{keywordtype}{void} generalized\_partition(idIteratorType idx\_in, idIteratorType idx\_in\_end, idIteratorType idx\_buffer,}
\DoxyCodeLine{45         countIteratorType offset, countIteratorType offset\_end,}
\DoxyCodeLine{46         functionType \textcolor{keyword}{const} partitioner) \{}
\DoxyCodeLine{47         }
\DoxyCodeLine{48         \textcolor{keywordtype}{int} \textcolor{keyword}{const} n\_segment = std::distance(offset, offset\_end) -\/ 1;}
\DoxyCodeLine{49         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} \textcolor{keyword}{const} id\_end = std::distance(idx\_in, idx\_in\_end);}
\DoxyCodeLine{50 }
\DoxyCodeLine{51         \textcolor{comment}{/* limit values */}}
\DoxyCodeLine{52         std::fill(offset, offset\_end -\/ 1, 0);}
\DoxyCodeLine{53         offset[n\_segment] = id\_end;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55         \textcolor{keywordflow}{if} (n\_segment == 1)}
\DoxyCodeLine{56             \textcolor{keywordflow}{return};}
\DoxyCodeLine{57         \textcolor{keywordflow}{if} (id\_end == 0)}
\DoxyCodeLine{58             \textcolor{keywordflow}{return};}
\DoxyCodeLine{59 }
\DoxyCodeLine{60         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end -\/ 1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{61             \textcolor{keyword}{auto} key = partitioner(idx\_in[i]);}
\DoxyCodeLine{62             ++offset[key];}
\DoxyCodeLine{63         \}}
\DoxyCodeLine{64         }
\DoxyCodeLine{65         std::partial\_sum(offset, offset + n\_segment, offset);}
\DoxyCodeLine{66 }
\DoxyCodeLine{67         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end -\/ 1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{68             \textcolor{keyword}{auto} idx = idx\_in[i];}
\DoxyCodeLine{69             \textcolor{keyword}{auto} key = partitioner(idx);}
\DoxyCodeLine{70             idx\_buffer[-\/-\/offset[key]] = idx;}
\DoxyCodeLine{71         \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73         std::copy(idx\_buffer, idx\_buffer + id\_end, idx\_in);}
\DoxyCodeLine{74     \}}
\DoxyCodeLine{75 }
\DoxyCodeLine{76     \textcolor{comment}{/*}}
\DoxyCodeLine{77 \textcolor{comment}{    function to partition into n section}}
\DoxyCodeLine{78 \textcolor{comment}{    */}}
\DoxyCodeLine{79     \textcolor{keyword}{template} <\textcolor{keyword}{class} \textcolor{keywordtype}{id}IteratorType, \textcolor{keyword}{class} \textcolor{keywordtype}{id}Type, \textcolor{keyword}{class} countIteratorType, \textcolor{keyword}{class} functionType>}
\DoxyCodeLine{80     \textcolor{keywordtype}{void} generalized\_partition\_from\_iota(idIteratorType idx\_in, idIteratorType idx\_in\_end, idType \textcolor{keyword}{const} iotaOffset,}
\DoxyCodeLine{81         countIteratorType offset, countIteratorType offset\_end,}
\DoxyCodeLine{82         functionType \textcolor{keyword}{const} partitioner) \{}
\DoxyCodeLine{83 }
\DoxyCodeLine{84         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} iota\_offset = iotaOffset;}
\DoxyCodeLine{85         \textcolor{keywordtype}{int} \textcolor{keyword}{const} n\_segment = std::distance(offset, offset\_end) -\/ 1;}
\DoxyCodeLine{86         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} \textcolor{keyword}{const} id\_end = std::distance(idx\_in, idx\_in\_end);}
\DoxyCodeLine{87 }
\DoxyCodeLine{88         \textcolor{comment}{/* limit values */}}
\DoxyCodeLine{89         std::fill(offset, offset\_end -\/ 1, 0);}
\DoxyCodeLine{90         offset[n\_segment] = id\_end;}
\DoxyCodeLine{91 }
\DoxyCodeLine{92         \textcolor{keywordflow}{if} (n\_segment == 1) \{}
\DoxyCodeLine{93             parallel\_iota(idx\_in, idx\_in\_end, iota\_offset);}
\DoxyCodeLine{94             \textcolor{keywordflow}{return};}
\DoxyCodeLine{95         \}}
\DoxyCodeLine{96         \textcolor{keywordflow}{if} (id\_end == 0)}
\DoxyCodeLine{97             \textcolor{keywordflow}{return};}
\DoxyCodeLine{98 }
\DoxyCodeLine{99         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end + iota\_offset -\/ 1; i >= iota\_offset; -\/-\/i) \{}
\DoxyCodeLine{100             \textcolor{keyword}{auto} key = partitioner(i);}
\DoxyCodeLine{101             ++offset[key];}
\DoxyCodeLine{102         \}   }
\DoxyCodeLine{103         }
\DoxyCodeLine{104         std::partial\_sum(offset, offset + n\_segment, offset);}
\DoxyCodeLine{105 }
\DoxyCodeLine{106         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end + iota\_offset -\/ 1; i >= iota\_offset; -\/-\/i) \{}
\DoxyCodeLine{107             \textcolor{keyword}{auto} key = partitioner(i);}
\DoxyCodeLine{108             idx\_in[-\/-\/offset[key]] = i;}
\DoxyCodeLine{109         \}}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112 }
\DoxyCodeLine{113     \textcolor{comment}{/*}}
\DoxyCodeLine{114 \textcolor{comment}{    function to partition into n section}}
\DoxyCodeLine{115 \textcolor{comment}{    */}}
\DoxyCodeLine{116     \textcolor{keyword}{template} <\textcolor{keyword}{class} \textcolor{keywordtype}{id}IteratorType, \textcolor{keyword}{class} countIteratorType, \textcolor{keyword}{class} functionType>}
\DoxyCodeLine{117     \textcolor{keywordtype}{void} parallel\_generalized\_partition(idIteratorType idx\_in, idIteratorType idx\_in\_end, idIteratorType idx\_buffer,}
\DoxyCodeLine{118         countIteratorType offset, countIteratorType offset\_end,}
\DoxyCodeLine{119         functionType \textcolor{keyword}{const} partitioner) \{}
\DoxyCodeLine{120         }
\DoxyCodeLine{121         \textcolor{keywordtype}{int} \textcolor{keyword}{const} n\_segment = std::distance(offset, offset\_end) -\/ 1;}
\DoxyCodeLine{122         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} \textcolor{keyword}{const} id\_end = std::distance(idx\_in, idx\_in\_end);}
\DoxyCodeLine{123 }
\DoxyCodeLine{124         \textcolor{comment}{/* limit values */}}
\DoxyCodeLine{125         offset[0] = 0;}
\DoxyCodeLine{126         offset[n\_segment] = id\_end;}
\DoxyCodeLine{127 }
\DoxyCodeLine{128         \textcolor{keywordflow}{if} (n\_segment == 1)}
\DoxyCodeLine{129             \textcolor{keywordflow}{return};}
\DoxyCodeLine{130         \textcolor{keywordflow}{if} (id\_end == 0) \{}
\DoxyCodeLine{131             std::fill(offset, offset\_end, 0);}
\DoxyCodeLine{132             \textcolor{keywordflow}{return};}
\DoxyCodeLine{133         \}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135         \textcolor{comment}{/* number of threads */}}
\DoxyCodeLine{136         \textcolor{keywordtype}{int} num\_threads;}
\DoxyCodeLine{137 \textcolor{preprocessor}{        \#pragma omp parallel}}
\DoxyCodeLine{138 \textcolor{preprocessor}{        \#pragma omp single}}
\DoxyCodeLine{139         num\_threads = omp\_get\_num\_threads();}
\DoxyCodeLine{140 }
\DoxyCodeLine{141         std::vector<size\_t> count(n\_segment*num\_threads, 0);}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{preprocessor}{        \#pragma omp parallel}}
\DoxyCodeLine{144         \{}
\DoxyCodeLine{145             \textcolor{keywordtype}{int} thread\_id = omp\_get\_thread\_num();}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{preprocessor}{            \#pragma omp for }}
\DoxyCodeLine{148             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end -\/ 1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{149                 \textcolor{keyword}{auto} key = partitioner(idx\_in[i]);}
\DoxyCodeLine{150                 ++count[key*num\_threads + thread\_id];}
\DoxyCodeLine{151             \}}
\DoxyCodeLine{152         \}}
\DoxyCodeLine{153         }
\DoxyCodeLine{154         \_\_gnu\_parallel::partial\_sum(count.begin(), count.begin() + n\_segment*num\_threads, count.begin());}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 \textcolor{preprocessor}{        \#pragma omp parallel}}
\DoxyCodeLine{157         \{}
\DoxyCodeLine{158             \textcolor{keywordtype}{int} thread\_id = omp\_get\_thread\_num();}
\DoxyCodeLine{159             }
\DoxyCodeLine{160 \textcolor{preprocessor}{            \#pragma omp for }}
\DoxyCodeLine{161             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end -\/ 1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{162                 \textcolor{keyword}{auto} idx = idx\_in[i];}
\DoxyCodeLine{163                 \textcolor{keyword}{auto} key = partitioner(idx);}
\DoxyCodeLine{164                 idx\_buffer[-\/-\/count[key*num\_threads + thread\_id]] = idx;}
\DoxyCodeLine{165             \}}
\DoxyCodeLine{166         \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{preprocessor}{        \#pragma omp parallel for }}
\DoxyCodeLine{169         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < n\_segment; ++i)}
\DoxyCodeLine{170             offset[i] = count[i*num\_threads];}
\DoxyCodeLine{171 }
\DoxyCodeLine{172         std::copy(idx\_buffer, idx\_buffer + id\_end, idx\_in);}
\DoxyCodeLine{173     \}}
\DoxyCodeLine{174 }
\DoxyCodeLine{175     \textcolor{comment}{/*}}
\DoxyCodeLine{176 \textcolor{comment}{    function to partition into n section}}
\DoxyCodeLine{177 \textcolor{comment}{    */}}
\DoxyCodeLine{178     \textcolor{keyword}{template} <\textcolor{keyword}{class} \textcolor{keywordtype}{id}IteratorType, \textcolor{keyword}{class} \textcolor{keywordtype}{id}Type, \textcolor{keyword}{class} countIteratorType, \textcolor{keyword}{class} functionType>}
\DoxyCodeLine{179     \textcolor{keywordtype}{void} parallel\_generalized\_partition\_from\_iota(idIteratorType idx\_in, idIteratorType idx\_in\_end, idType \textcolor{keyword}{const} iotaOffset,}
\DoxyCodeLine{180         countIteratorType offset, countIteratorType offset\_end,}
\DoxyCodeLine{181         functionType \textcolor{keyword}{const} partitioner) \{}
\DoxyCodeLine{182 }
\DoxyCodeLine{183         \textcolor{keywordtype}{int} \textcolor{keyword}{const} n\_segment = std::distance(offset, offset\_end) -\/ 1;}
\DoxyCodeLine{184         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} \textcolor{keyword}{const} id\_end = std::distance(idx\_in, idx\_in\_end);}
\DoxyCodeLine{185 }
\DoxyCodeLine{186         \textcolor{comment}{/* limit values */}}
\DoxyCodeLine{187         offset[0] = 0;}
\DoxyCodeLine{188         offset[n\_segment] = id\_end;}
\DoxyCodeLine{189 }
\DoxyCodeLine{190         \textcolor{keywordflow}{if} (n\_segment == 1)}
\DoxyCodeLine{191             \textcolor{keywordflow}{return};}
\DoxyCodeLine{192         \textcolor{keywordflow}{if} (id\_end == 0) \{}
\DoxyCodeLine{193             std::fill(offset, offset\_end, 0);}
\DoxyCodeLine{194             \textcolor{keywordflow}{return};}
\DoxyCodeLine{195         \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197         \textcolor{comment}{/* number of threads */}}
\DoxyCodeLine{198         \textcolor{keywordtype}{int} num\_threads;}
\DoxyCodeLine{199 \textcolor{preprocessor}{        \#pragma omp parallel}}
\DoxyCodeLine{200 \textcolor{preprocessor}{        \#pragma omp single}}
\DoxyCodeLine{201         num\_threads = omp\_get\_num\_threads();}
\DoxyCodeLine{202 }
\DoxyCodeLine{203         std::vector<size\_t> count(n\_segment*num\_threads, 0);}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{preprocessor}{        \#pragma omp parallel}}
\DoxyCodeLine{206         \{}
\DoxyCodeLine{207             \textcolor{keywordtype}{int} thread\_id = omp\_get\_thread\_num();}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{preprocessor}{            \#pragma omp for }}
\DoxyCodeLine{210             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end + iotaOffset -\/ 1; i >= iotaOffset; -\/-\/i) \{}
\DoxyCodeLine{211                 \textcolor{keyword}{auto} key = partitioner(i);}
\DoxyCodeLine{212                 ++count[key*num\_threads + thread\_id];}
\DoxyCodeLine{213             \}}
\DoxyCodeLine{214         \}}
\DoxyCodeLine{215         }
\DoxyCodeLine{216         \_\_gnu\_parallel::partial\_sum(count.begin(), count.begin() + n\_segment*num\_threads, count.begin());}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 \textcolor{preprocessor}{        \#pragma omp parallel}}
\DoxyCodeLine{219         \{}
\DoxyCodeLine{220             \textcolor{keywordtype}{int} thread\_id = omp\_get\_thread\_num();}
\DoxyCodeLine{221             }
\DoxyCodeLine{222 \textcolor{preprocessor}{            \#pragma omp for }}
\DoxyCodeLine{223             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = id\_end + iotaOffset -\/ 1; i >= iotaOffset; -\/-\/i) \{}
\DoxyCodeLine{224                 \textcolor{keyword}{auto} key = partitioner(i);}
\DoxyCodeLine{225                 idx\_in[-\/-\/count[key*num\_threads + thread\_id]] = i;}
\DoxyCodeLine{226             \}}
\DoxyCodeLine{227         \}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{preprocessor}{        \#pragma omp parallel for }}
\DoxyCodeLine{230         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < n\_segment; ++i)}
\DoxyCodeLine{231             offset[i] = count[i*num\_threads];}
\DoxyCodeLine{232     \}}
\DoxyCodeLine{233 \}}

\end{DoxyCode}
