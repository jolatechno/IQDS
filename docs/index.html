<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuIDS: Quantum Irregular Dynamic Simulator: &lt;a href=&quot;https://github.com/jolatechno/QuIDS&quot; &gt;QuIDS&lt;/a&gt;: Quantum Irregular Dynamic Simulator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QuIDS: Quantum Irregular Dynamic Simulator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a href="https://github.com/jolatechno/QuIDS">QuIDS</a>: Quantum Irregular Dynamic Simulator </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<p >This library is header-only, so you can simply link files in <a href="./src">src</a>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Requirements</h2>
<p >The only requirement is to have at least <code>c++2a</code>. Parallelism is implemented using <code>OpenMP</code>, although the pure <code>MPI</code> implementation is more efficient right now.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Documentation</h1>
<p >The code is documented using <code>doxygen</code>. Documentation is present (html format) in <a href="./docs/">docs/</a> and is also hosted at <a href="https://jolatechno.github.io/QuIDS/">jolatechno.github.io/QuIDS/</a>.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
file examples</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
dynamics</h3>
<p >Some rules that can be used directly, or understood as examples are implemented in <a href="./src/rules">src/rules</a> (see <a href="./files.html">Files</a>/src/rules if you are using docs).</p>
<p ><a href="./src/rules/qcgd.hpp">src/rules/qcgd.hpp</a> (see <a href="./files.html">Files</a>/src/rules/qcgd.hpp if you are using docs) is the implementation of Quantum Causal Graph Dynamics (QCGDs) used in <a href="https://github.com/jolatechno/Quantum-graph-simulation">jolatechno/Quantum-graph-simulation</a>. It <em>is not meant to be readable</em>, and is only used as a repeatable, complex performance demonstrator and research tool for the field of QCGDs.</p>
<p >At the contrary, <a href="./src/rules/quantum_computer.hpp">src/rules/quantum_computer.hpp</a> (see <a href="./files.html">Files</a>/src/rules/quantum_computer.hpp if you are using docs) is a simpler <em>understandable</em> example of multiple modifier, and of a dynamic (the hadamard gate).</p>
<h3><a class="anchor" id="autotoc_md7"></a>
usage example</h3>
<p ><a href="./examples/quantum_computer_test.cpp">examples/quantum_computer_test.cpp</a> (see <a href="./files.html">Files</a>/examples/quantum_computer_test.cpp if you are using docs) is a simple <code>OPENMP</code>-only example.</p>
<p >Similarly, <a href="./examples/mpi_test.cpp">examples/mpi_test.cpp</a> (see <a href="./files.html">Files</a>/examples/mpi_test.cpp if you are using docs) is a simple <code>MPI</code>/<code>OPENMP</code> hybrid example, demonstrating how to port a <code>OPENMP</code>-only implementation to <code>MPI</code>, and demonstrating some <code>MPI</code>-specific functions.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
description</h2>
<p >Objects are represented by a simple begin and end pointer. Their exist two kind of interfaces for implementing a unitary transformation.</p>
<p ><code>modifiers</code> and <code>rules</code> are applied using the <code>quids::simulate(...)</code> function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;src/quids.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    <span class="comment">/* variables*/</span></div>
<div class="line">    <a class="code hl_typedef" href="namespacequids.html#a60a676728450b703f98f219a0ee7e5f2">quids::it_t</a> next_state, state;</div>
<div class="line">    <a class="code hl_typedef" href="namespacequids.html#a2f3cfcb2f4d55d58993493426aafb2fe">quids::sy_it_t</a> symbolic_iteration;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initializing the state */</span></div>
<div class="line">    state.append(object_begin, object_end);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* applying a modifier */</span></div>
<div class="line">    <a class="code hl_function" href="namespacequids.html#a0cd589223d6f94d98d0d52849bfcd76a">quids::simulate</a>(state, my_modifier);</div>
<div class="line">    <a class="code hl_function" href="namespacequids.html#a0cd589223d6f94d98d0d52849bfcd76a">quids::simulate</a>(state, [](<span class="keywordtype">char</span> *parent_begin, <span class="keywordtype">char</span> *parent_end, std::complex&lt;PROBA_TYPE&gt; &amp;mag) {</div>
<div class="line">            <span class="comment">/* using lambda-expressions */</span></div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* applying a rule */</span></div>
<div class="line">    <a class="code hl_typedef" href="namespacequids.html#a62455c8f5240a575676aace3a25dfae3">quids::rule_t</a> *rule = <span class="keyword">new</span> my_rule(<span class="comment">/*...*/</span>);</div>
<div class="line">    <a class="code hl_function" href="namespacequids.html#a0cd589223d6f94d98d0d52849bfcd76a">quids::simulate</a>(state, rule, next_state, symbolic_iteration);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* &quot;next_state&quot; now holds an application of &quot;rule&quot; on &quot;state&quot; */</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacequids_html_a0cd589223d6f94d98d0d52849bfcd76a"><div class="ttname"><a href="namespacequids.html#a0cd589223d6f94d98d0d52849bfcd76a">quids::simulate</a></div><div class="ttdeci">void simulate(it_t &amp;iteration, modifier_t const rule)</div><div class="ttdoc">function to apply a modifer to a wave function</div><div class="ttdef"><b>Definition:</b> quids.hpp:431</div></div>
<div class="ttc" id="anamespacequids_html_a2f3cfcb2f4d55d58993493426aafb2fe"><div class="ttname"><a href="namespacequids.html#a2f3cfcb2f4d55d58993493426aafb2fe">quids::sy_it_t</a></div><div class="ttdeci">class symbolic_iteration sy_it_t</div><div class="ttdoc">symbolic iteration type</div><div class="ttdef"><b>Definition:</b> quids.hpp:77</div></div>
<div class="ttc" id="anamespacequids_html_a60a676728450b703f98f219a0ee7e5f2"><div class="ttname"><a href="namespacequids.html#a60a676728450b703f98f219a0ee7e5f2">quids::it_t</a></div><div class="ttdeci">class iteration it_t</div><div class="ttdoc">iteration class type</div><div class="ttdef"><b>Definition:</b> quids.hpp:75</div></div>
<div class="ttc" id="anamespacequids_html_a62455c8f5240a575676aace3a25dfae3"><div class="ttname"><a href="namespacequids.html#a62455c8f5240a575676aace3a25dfae3">quids::rule_t</a></div><div class="ttdeci">class rule rule_t</div><div class="ttdoc">dynamic (or rule) type</div><div class="ttdef"><b>Definition:</b> quids.hpp:79</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
MPI support</h2>
<p >Simulations can also be done across nodes. For that, you'll need to replace <code>quids::sy_it</code> and <code><a class="el" href="namespacequids.html#a60a676728450b703f98f219a0ee7e5f2" title="iteration class type">quids::it_t</a></code> respectivly by <code>quids::mpi::mpi_sy_it</code> and <code><a class="el" href="namespacequids_1_1mpi.html#a35f6cb8275fdb46ab6042a3e4bd799ba" title="mpi iteration type">quids::mpi::mpi_it_t</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="quids__mpi_8hpp.html">src/quids_mpi.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    <span class="comment">/* MPI initialization */</span></div>
<div class="line">    <span class="keywordtype">int</span> size, rank, provided;</div>
<div class="line">    MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_SERIALIZED, &amp;provided);</div>
<div class="line">    <span class="keywordflow">if</span>(provided &lt; MPI_THREAD_SERIALIZED) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;The threading support level is lesser than that demanded.\n&quot;</span>);</div>
<div class="line">        MPI_Abort(MPI_COMM_WORLD, EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* variables*/</span></div>
<div class="line">    <a class="code hl_typedef" href="namespacequids_1_1mpi.html#a35f6cb8275fdb46ab6042a3e4bd799ba">quids::mpi::mpi_it_t</a> next_state, state;</div>
<div class="line">    <a class="code hl_typedef" href="namespacequids_1_1mpi.html#a3e3b2dbb59ff2b0f9b997fb9bf196cc8">quids::mpi::mpi_sy_it_t</a> symbolic_iteration;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initializing the state */</span></div>
<div class="line">    state.append(object_begin, object_end);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* applying a modifier */</span></div>
<div class="line">    <a class="code hl_function" href="namespacequids.html#a0cd589223d6f94d98d0d52849bfcd76a">quids::simulate</a>(state, my_modifier);</div>
<div class="line">    <a class="code hl_function" href="namespacequids.html#a0cd589223d6f94d98d0d52849bfcd76a">quids::simulate</a>(state, [](<span class="keywordtype">char</span> *parent_begin, <span class="keywordtype">char</span> *parent_end, std::complex&lt;PROBA_TYPE&gt; &amp;mag) {</div>
<div class="line">            <span class="comment">/* using lambda-expressions */</span></div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* applying a rule */</span></div>
<div class="line">    <a class="code hl_typedef" href="namespacequids.html#a62455c8f5240a575676aace3a25dfae3">quids::rule_t</a> *rule = <span class="keyword">new</span> my_rule(<span class="comment">/*...*/</span>);</div>
<div class="line">    <a class="code hl_function" href="namespacequids_1_1mpi.html#ab589d2622e28bfe6e3522a103c841450">quids::mpi::simulate</a>(state, rule, next_state, symbolic_iteration, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* &quot;next_state&quot; now holds an application of &quot;rule&quot; on &quot;state&quot; */</span></div>
<div class="line"> </div>
<div class="line">    MPI_Finalize();</div>
<div class="line">}</div>
<div class="ttc" id="anamespacequids_1_1mpi_html_a35f6cb8275fdb46ab6042a3e4bd799ba"><div class="ttname"><a href="namespacequids_1_1mpi.html#a35f6cb8275fdb46ab6042a3e4bd799ba">quids::mpi::mpi_it_t</a></div><div class="ttdeci">class mpi_iteration mpi_it_t</div><div class="ttdoc">mpi iteration type</div><div class="ttdef"><b>Definition:</b> quids_mpi.hpp:59</div></div>
<div class="ttc" id="anamespacequids_1_1mpi_html_a3e3b2dbb59ff2b0f9b997fb9bf196cc8"><div class="ttname"><a href="namespacequids_1_1mpi.html#a3e3b2dbb59ff2b0f9b997fb9bf196cc8">quids::mpi::mpi_sy_it_t</a></div><div class="ttdeci">class mpi_symbolic_iteration mpi_sy_it_t</div><div class="ttdoc">mpi symbolic iteration type</div><div class="ttdef"><b>Definition:</b> quids_mpi.hpp:61</div></div>
<div class="ttc" id="anamespacequids_1_1mpi_html_ab589d2622e28bfe6e3522a103c841450"><div class="ttname"><a href="namespacequids_1_1mpi.html#ab589d2622e28bfe6e3522a103c841450">quids::mpi::simulate</a></div><div class="ttdeci">void simulate(mpi_it_t &amp;iteration, quids::rule_t const *rule, mpi_it_t &amp;next_iteration, mpi_sy_it_t &amp;symbolic_iteration, MPI_Comm communicator, size_t max_num_object=0, quids::debug_t mid_step_function=[](const char *){})</div><div class="ttdoc">function to apply a dynamic to a wave function distributed accross multiple nodes</div><div class="ttdef"><b>Definition:</b> quids_mpi.hpp:422</div></div>
<div class="ttc" id="aquids__mpi_8hpp_html"><div class="ttname"><a href="quids__mpi_8hpp.html">quids_mpi.hpp</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Modifiers</h2>
<p >A <code>modifier</code> is a simple functions that takes a objects, and modify it in place, while keep its size unchanged.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_modifier(<span class="keywordtype">char</span> *parent_begin, <span class="keywordtype">char</span> *parent_end, std::complex&lt;PROBA_TYPE&gt; &amp;mag) {</div>
<div class="line">    <span class="comment">// modify the object...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Rules</h2>
<p >A <code>rule</code> is a simple class, implementing 2 functions (with a third being optional).</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_rule : <span class="keyword">public</span> <a class="code hl_typedef" href="namespacequids.html#a62455c8f5240a575676aace3a25dfae3">quids::rule_t</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    my_rule() {};</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> get_num_child(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end, </div>
<div class="line">        uint &amp;num_child, uint &amp;max_child_size) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> populate_child(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end,</div>
<div class="line">        <span class="keywordtype">char</span>* <span class="keyword">const</span> child_begin, uint <span class="keyword">const</span> child_id,</div>
<div class="line">        uint &amp;size, std::complex&lt;PROBA_TYPE&gt; &amp;mag) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> populate_child_simple(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end,</div>
<div class="line">        <span class="keywordtype">char</span>* <span class="keyword">const</span> child_begin, uint <span class="keyword">const</span> child_id) <span class="keyword">const</span>; <span class="comment">// optional</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">size_t</span> hasher(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end) <span class="keyword">const</span>; <span class="comment">// optional</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >The first function, <code>get_num_child(...)</code>, finds the number of objects created through the unitary transform by a given objects. It also gives an upper-bound to the size of those objects.</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> my_rule::get_num_child(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end,</div>
<div class="line">    uint &amp;num_child, uint &amp;max_child_size)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// do stuff...</span></div>
<div class="line">    num_child = actual_num_child;</div>
<div class="line">    max_child_size = actual_max_child_size;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The second function, <code>populate_child(...)</code>, simply "populate" (create) an object from its parent, while also modifying its magnitude according to the unitary transformation (the starting magnitude is the parent magnitude).</p>
<p >Note that <code>child_id</code> is a number from <code>0</code> to <code>num_child</code>, and simply identify "child" amoung its "siblings" (objects with the same "parent").</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> populate_child(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end,</div>
<div class="line">    <span class="keywordtype">char</span>* <span class="keyword">const</span> child_begin, uint <span class="keyword">const</span> child_id,</div>
<div class="line">    uint &amp;size, std::complex&lt;PROBA_TYPE&gt; &amp;mag)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// modify mag...</span></div>
<div class="line">    <span class="comment">// populate the child, starting at child_begin</span></div>
<div class="line">    size = actual_child_size;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The third function is <code>populate_child_simple(...)</code> which is simply a copy of <code>populate_child(...)</code> that can skip the computation of the magnitude and the size of the child objects. If not provided the default implementation relize on <code>populate_child(...)</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> populate_child_simple(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end,</div>
<div class="line">    <span class="keywordtype">char</span>* <span class="keyword">const</span> child_begin, uint <span class="keyword">const</span> child_id)<span class="keyword"> const </span>{ <span class="comment">//can be overwritten</span></div>
<div class="line">        uint size_placeholder;</div>
<div class="line">        <a class="code hl_typedef" href="namespacequids.html#a13a066a7f98435d1c84f2318439d4f0b">mag_t</a> mag_placeholder;</div>
<div class="line">        populate_child(parent_begin, parent_end, child_begin, child_id,</div>
<div class="line">            size_placeholder, mag_placeholder);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacequids_html_a13a066a7f98435d1c84f2318439d4f0b"><div class="ttname"><a href="namespacequids.html#a13a066a7f98435d1c84f2318439d4f0b">quids::mag_t</a></div><div class="ttdeci">std::complex&lt; PROBA_TYPE &gt; mag_t</div><div class="ttdoc">complex magnitude type</div><div class="ttdef"><b>Definition:</b> quids.hpp:73</div></div>
</div><!-- fragment --><p >The last function is a hasher for objects. If not specified, the whole memory buffer will simply be hashed. A hasher NEEDS to be provided if objects that are equal can be represented by different objects. The default implementation is:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">size_t</span> my_rule::hasher(<span class="keywordtype">char</span> <span class="keyword">const</span> *parent_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *parent_end)<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::hash&lt;std::string_view&gt;()(</div>
<div class="line">        std::string_view(parent_begin, std::distance(parent_begin, parent_end)));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Interaction with the different classes</h2>
<p >We can see that a quantum state is represented by a specific <code>iteration</code> class, and a <code>symbolic_iteration</code> is generated when applying a unitary transformation on a state. We interact with those classes (modify or read a state, ect...) through public member functions and variables, which will be shortly documented bellow, as they are vital to building a <b>usefull</b> program using <code>QuIDS</code>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Symbolic iteration</h3>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">class </span>symbolic_iteration <a class="code hl_typedef" href="namespacequids.html#a2f3cfcb2f4d55d58993493426aafb2fe">sy_it_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>symbolic_iteration {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">size_t</span> num_object = 0;</div>
<div class="line">    <span class="keywordtype">size_t</span> num_object_after_interferences = 0;</div>
<div class="line"> </div>
<div class="line">    symbolic_iteration() {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">/*...*/</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >The <code>symbolic_iteration</code> class (or <code>sy_it_t</code> type) only has a basic constructor, as it is only ment to be used internaly.</p>
<p >Member variables are:</p><ul>
<li><code>num_object</code> : Number of objects generated at symbolic iteration (before interferences and truncation).</li>
<li><code>num_object_after_interferences</code> : Number of objects after eliminating duplicates (so called "interferences"), but before truncation.</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
Iteration</h3>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">class </span>iteration <a class="code hl_typedef" href="namespacequids.html#a60a676728450b703f98f219a0ee7e5f2">it_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>iteration {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">size_t</span> num_object = 0;</div>
<div class="line">    PROBA_TYPE total_proba = 1;</div>
<div class="line"> </div>
<div class="line">    iteration();</div>
<div class="line">    iteration(<span class="keywordtype">char</span>* object_begin_, <span class="keywordtype">char</span>* object_end_);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> append(<span class="keywordtype">char</span> <span class="keyword">const</span> *object_begin_, <span class="keywordtype">char</span> <span class="keyword">const</span> *object_end_, std::complex&lt;PROBA_TYPE&gt; <span class="keyword">const</span> mag=1);</div>
<div class="line">    <span class="keywordtype">void</span> pop(uint n=1, <span class="keywordtype">bool</span> normalize_=<span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordtype">void</span> get_object(<span class="keywordtype">size_t</span> <span class="keyword">const</span> object_id, <span class="keywordtype">char</span> *&amp; object_begin, uint &amp;object_size, std::complex&lt;PROBA_TYPE&gt; *&amp;mag);</div>
<div class="line">    <span class="keywordtype">void</span> get_object(<span class="keywordtype">size_t</span> <span class="keyword">const</span> object_id, <span class="keywordtype">char</span> <span class="keyword">const</span> *&amp; object_begin, uint &amp;object_size, std::complex&lt;PROBA_TYPE&gt; &amp;mag) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    T average_value(std::function&lt;T(<span class="keywordtype">char</span> <span class="keyword">const</span> *object_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *object_end)&gt; <span class="keyword">const</span> &amp;observable) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">/*...*/</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >The <code>iteration</code> class (or <code>it_t</code> type) has two constructors, a basic one, and one that simply takes a starting object and append it to the state with probability one.</p>
<p >Member functions are:</p><ul>
<li><code>append(...)</code> : Append an object to the state, with a give magnitude (default = 1).</li>
<li><code>pop(...)</code> : Remove the <code>n</code> last objects, and normalze (if <code>normalize_</code> is <code>true</code>).</li>
<li><code>get_object(...)</code> : Allows to read (either as constant or not) an objects and its magnitude, with a given <code>object_id</code> between 0 and <code>num_object</code>. Note that the non-constant function takes pointers for <code>mag</code>.</li>
<li><code>average_value(...)</code> : Compute the average value of an observable (a function) of any type (that can be added, initialized by <code>T x = 0</code>, and multiplied by an object of type <code>PROBA_TYPE</code>).</li>
</ul>
<p >Member variables are:</p><ul>
<li><code>num_object</code> : Number of object describing this state currently in superposition.</li>
<li><code>total_proba</code> : total probability held by this state before normalizing it (so after truncation).</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
MPI symbolic iteration</h3>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">class </span>mpi_symbolic_iteration <a class="code hl_typedef" href="namespacequids_1_1mpi.html#a3e3b2dbb59ff2b0f9b997fb9bf196cc8">mpi_sy_it_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>mpi_symbolic_iteration : <span class="keyword">public</span> <a class="code hl_class" href="classquids_1_1symbolic__iteration.html">quids::symbolic_iteration</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">size_t</span> get_total_num_object(MPI_Comm communicator) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> get_total_num_object_after_interferences(MPI_Comm communicator) <span class="keyword">const</span>;</div>
<div class="line">    mpi_symbolic_iteration() {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">/*...*/</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassquids_1_1symbolic__iteration_html"><div class="ttname"><a href="classquids_1_1symbolic__iteration.html">quids::symbolic_iteration</a></div><div class="ttdoc">symbolic iteration (computation intermediary)</div><div class="ttdef"><b>Definition:</b> quids.hpp:333</div></div>
</div><!-- fragment --><p >The <code>mpi_symbolic_iteration</code> class (or <code>mpi_sy_it_t</code> type) can be considered as exactly equivalent to the <code>symbolic_iteration</code> class (or <code>sy_it_t</code> type).</p>
<p >The two added member functions are:</p><ul>
<li><code>get_total_num_object(...)</code> : Get the total number of object at symbolic iteration accross all nodes.</li>
<li><code>get_total_num_object_after_interferences(...)</code> : Get the total number of object at symbolic iteration, after interferences but before truncation, accross all nodes.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16"></a>
MPI iteration</h3>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">class </span>mpi_iteration <a class="code hl_typedef" href="namespacequids_1_1mpi.html#a35f6cb8275fdb46ab6042a3e4bd799ba">mpi_it_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>mpi_iteration : <span class="keyword">public</span> <a class="code hl_class" href="classquids_1_1iteration.html">quids::iteration</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PROBA_TYPE node_total_proba = 0;</div>
<div class="line"> </div>
<div class="line">    mpi_iteration() {}</div>
<div class="line">    mpi_iteration(<span class="keywordtype">char</span>* object_begin_, <span class="keywordtype">char</span>* object_end_) : <a class="code hl_namespace" href="namespacequids.html">quids</a>::iteration(object_begin_, object_end_) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> equalize(MPI_Comm communicator);</div>
<div class="line">    <span class="keywordtype">size_t</span> get_total_num_object(MPI_Comm communicator) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> send_objects(<span class="keywordtype">size_t</span> num_object_sent, <span class="keywordtype">int</span> node, MPI_Comm communicator);</div>
<div class="line">    <span class="keywordtype">void</span> receive_objects(<span class="keywordtype">int</span> node, MPI_Comm communicator);</div>
<div class="line">    <span class="keywordtype">void</span> distribute_objects(MPI_Comm comunicator, <span class="keywordtype">int</span> node_id);</div>
<div class="line">    <span class="keywordtype">void</span> gather_objects(MPI_Comm comunicator, <span class="keywordtype">int</span> node_id);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    T <a class="code hl_function" href="classquids_1_1iteration.html#a605ea87c36fba513f9ced985a56a14f0">average_value</a>(std::function&lt;T(<span class="keywordtype">char</span> <span class="keyword">const</span> *object_begin, <span class="keywordtype">char</span> <span class="keyword">const</span> *object_end)&gt; <span class="keyword">const</span> &amp;observable, MPI_Comm communicator) <span class="keyword">const</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">/*...*/</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassquids_1_1iteration_html"><div class="ttname"><a href="classquids_1_1iteration.html">quids::iteration</a></div><div class="ttdoc">iteration (wave function) representation class</div><div class="ttdef"><b>Definition:</b> quids.hpp:144</div></div>
<div class="ttc" id="aclassquids_1_1iteration_html_a605ea87c36fba513f9ced985a56a14f0"><div class="ttname"><a href="classquids_1_1iteration.html#a605ea87c36fba513f9ced985a56a14f0">quids::iteration::average_value</a></div><div class="ttdeci">PROBA_TYPE average_value(const observable_t observable) const</div><div class="ttdoc">function to get the average value of a custom observable</div><div class="ttdef"><b>Definition:</b> quids.hpp:203</div></div>
<div class="ttc" id="anamespacequids_html"><div class="ttname"><a href="namespacequids.html">quids</a></div><div class="ttdoc">QuIDS namespace.</div><div class="ttdef"><b>Definition:</b> quids.hpp:55</div></div>
</div><!-- fragment --><p >The <code>mpi_iteration</code> class (or <code>mpi_it_t</code> type) inehrits all the public memeber functions and varibale of the <code>iteration</code> class (or <code>it_t</code> type), and shares similar constructors.</p>
<p >The additional member functions are:</p><ul>
<li><code>equalize(...)</code> : Does its best at equalizing the number of object on each node. Will only equalize among pair (in hopefully the optimal pair-arangment), so it's up to you to check if the objects are equally shared among nodes, as some spetial cases can't be equalized well by this algorithm. <code>normalize(MPI_Comm ...)</code> should be after <code>equalize(...)</code> at the end to compute <code>node_total_proba</code>.</li>
<li><code>get_total_num_object(...)</code> : Get the total number of object accross all nodes.</li>
<li><code>send_objects(...)</code> : Send a given number of object to a node, and <code>pop</code> them of the sending one. <code>normalize(MPI_Comm ...)</code> should be after <code>send_objects(...)</code> at the end to compute <code>node_total_proba</code>.</li>
<li><code>receive_objects(...)</code> : Receiving end of the <code>send_objects(...)</code> function. <code>normalize(MPI_Comm ...)</code> should be after <code>receive_objects(...)</code> at the end to compute <code>node_total_proba</code>.</li>
<li><code>distribute_objects(..)</code> : Distribute objects that are located on a single node of id <code>node_id</code> (0 if not specified) equally on all other nodes. <code>normalize(MPI_Comm ...)</code> should be after <code>distribute_objects(...)</code> at the end to compute <code>node_total_proba</code>.</li>
<li><code>gather_objects(...)</code> : Gather objects on all nodes to the node of id <code>node_id</code> (0 if not specified). If all objects can't fit on the memory of this node, the function will throw a <code>bad alloc</code> error as the behavior is undefined. <code>node_total_proba</code> is calculated at the end as it doesn't require a calling <code>normalize(MPI_Comm ...)</code>.</li>
<li><code>average_value(...)</code> : equiavlent to the normal <code>iteration</code> member function, but for the whole distributed wave function (<b>note that calling</b> <code>average_value(...)</code> <b>without an</b> <code>MPI_Comm</code> <b>will return a local average value for retrocompatibility with the basic</b> <code>iteration</code> <b>class</b>).</li>
</ul>
<p ><code>node_total_proba</code> is the only additional member variable, and is the proportion of total probability that is held by a given node.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Global parameters and pre-processor flags</h2>
<p >In addition to classes, some global parameters are used to modify the behaviour of the simulation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef PROBA_TYPE</span></div>
<div class="line"><span class="preprocessor">    #define PROBA_TYPE double</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#ifndef HASH_MAP_OVERHEAD</span></div>
<div class="line"><span class="preprocessor">    #define HASH_MAP_OVERHEAD 1.7</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* other default-value flags */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacequids.html">quids</a> {</div>
<div class="line">    uint <a class="code hl_variable" href="namespacequids.html#ae8ca71b5e72f679e32a8b76f3c1280f3">align_byte_length</a> = ALIGNMENT_BYTE_LENGTH;</div>
<div class="line">    PROBA_TYPE <a class="code hl_variable" href="namespacequids.html#ae6148553f287fa7c670cc8d0a729fe8d">tolerance</a> = TOLERANCE;</div>
<div class="line">    <span class="keywordtype">float</span> <a class="code hl_variable" href="namespacequids.html#acf286be928cefbb5ad9e672e1999de1b">safety_margin</a> = SAFETY_MARGIN;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_variable" href="namespacequids.html#a967bbc4ed348a75e24789554a64f8d62">load_balancing_bucket_per_thread</a> = LOAD_BALANCING_BUCKET_PER_THREAD;</div>
<div class="line"><span class="preprocessor">    #ifdef SIMPLE_TRUNCATION</span></div>
<div class="line">        <span class="keywordtype">bool</span> <a class="code hl_variable" href="namespacequids.html#af08ec7fda63cfb6d458ad3bb10b31e4d">simple_truncation</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line">        <span class="keywordtype">bool</span> <a class="code hl_variable" href="namespacequids.html#af08ec7fda63cfb6d458ad3bb10b31e4d">simple_truncation</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>mpi {</div>
<div class="line">        <span class="keywordtype">size_t</span> <a class="code hl_variable" href="namespacequids_1_1mpi.html#a31fde7b46759670da2fe0f6b3731f5c0">min_equalize_size</a> = MIN_EQUALIZE_SIZE;</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_variable" href="namespacequids_1_1mpi.html#ab5de5240ccfc019063996bdc48e7a20b">equalize_inbalance</a> = EQUALIZE_INBALANCE;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* ... */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>utils {</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_variable" href="namespacequids_1_1utils.html#a90041f6130e71de649d376e77040893d">upsize_policy</a> = UPSIZE_POLICY;</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_variable" href="namespacequids_1_1utils.html#a1030df3ee43b5a7caf2fcc8e4e68e281">downsize_policy</a> = DOWNSIZE_POLICY;</div>
<div class="line">        <span class="keywordtype">size_t</span> <a class="code hl_variable" href="namespacequids_1_1utils.html#af6008a56b61821492cabc5d71d351938">min_vector_size</a> = MIN_VECTOR_SIZE;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* ... */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* ... */</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacequids_1_1mpi_html_a31fde7b46759670da2fe0f6b3731f5c0"><div class="ttname"><a href="namespacequids_1_1mpi.html#a31fde7b46759670da2fe0f6b3731f5c0">quids::mpi::min_equalize_size</a></div><div class="ttdeci">size_t min_equalize_size</div><div class="ttdoc">minimum number of object that should be attained (in at least one node) before equalizing (load-shari...</div><div class="ttdef"><b>Definition:</b> quids_mpi.hpp:46</div></div>
<div class="ttc" id="anamespacequids_1_1mpi_html_ab5de5240ccfc019063996bdc48e7a20b"><div class="ttname"><a href="namespacequids_1_1mpi.html#ab5de5240ccfc019063996bdc48e7a20b">quids::mpi::equalize_inbalance</a></div><div class="ttdeci">float equalize_inbalance</div><div class="ttdoc">maximum imbalance between nodes (max_obj - avg_obj)/max_obj allowed before equalizing.</div><div class="ttdef"><b>Definition:</b> quids_mpi.hpp:48</div></div>
<div class="ttc" id="anamespacequids_1_1utils_html_a1030df3ee43b5a7caf2fcc8e4e68e281"><div class="ttname"><a href="namespacequids_1_1utils.html#a1030df3ee43b5a7caf2fcc8e4e68e281">quids::utils::downsize_policy</a></div><div class="ttdeci">float downsize_policy</div><div class="ttdoc">size multiplicator when downsize_policy, to avoid repeated upsizing. !!! upsize_policy*downsize_polic...</div><div class="ttdef"><b>Definition:</b> vector.hpp:31</div></div>
<div class="ttc" id="anamespacequids_1_1utils_html_a90041f6130e71de649d376e77040893d"><div class="ttname"><a href="namespacequids_1_1utils.html#a90041f6130e71de649d376e77040893d">quids::utils::upsize_policy</a></div><div class="ttdeci">float upsize_policy</div><div class="ttdoc">size multiplicator when upsizing, to avoid repeated upsizing.</div><div class="ttdef"><b>Definition:</b> vector.hpp:29</div></div>
<div class="ttc" id="anamespacequids_1_1utils_html_af6008a56b61821492cabc5d71d351938"><div class="ttname"><a href="namespacequids_1_1utils.html#af6008a56b61821492cabc5d71d351938">quids::utils::min_vector_size</a></div><div class="ttdeci">size_t min_vector_size</div><div class="ttdoc">minimum size a vector is allocated to (to avoid resizing at small sizes).</div><div class="ttdef"><b>Definition:</b> vector.hpp:33</div></div>
<div class="ttc" id="anamespacequids_html_a967bbc4ed348a75e24789554a64f8d62"><div class="ttname"><a href="namespacequids.html#a967bbc4ed348a75e24789554a64f8d62">quids::load_balancing_bucket_per_thread</a></div><div class="ttdeci">int load_balancing_bucket_per_thread</div><div class="ttdoc">number of load balancing buckets per thread</div><div class="ttdef"><b>Definition:</b> quids.hpp:63</div></div>
<div class="ttc" id="anamespacequids_html_acf286be928cefbb5ad9e672e1999de1b"><div class="ttname"><a href="namespacequids.html#acf286be928cefbb5ad9e672e1999de1b">quids::safety_margin</a></div><div class="ttdeci">float safety_margin</div><div class="ttdoc">memory safety margin (0.2 = 80% memory usage target)</div><div class="ttdef"><b>Definition:</b> quids.hpp:61</div></div>
<div class="ttc" id="anamespacequids_html_ae6148553f287fa7c670cc8d0a729fe8d"><div class="ttname"><a href="namespacequids.html#ae6148553f287fa7c670cc8d0a729fe8d">quids::tolerance</a></div><div class="ttdeci">PROBA_TYPE tolerance</div><div class="ttdoc">tolerance for objects (remove objects with a smaller probability)</div><div class="ttdef"><b>Definition:</b> quids.hpp:59</div></div>
<div class="ttc" id="anamespacequids_html_ae8ca71b5e72f679e32a8b76f3c1280f3"><div class="ttname"><a href="namespacequids.html#ae8ca71b5e72f679e32a8b76f3c1280f3">quids::align_byte_length</a></div><div class="ttdeci">uint align_byte_length</div><div class="ttdoc">amount of byte to align objects to</div><div class="ttdef"><b>Definition:</b> quids.hpp:57</div></div>
<div class="ttc" id="anamespacequids_html_af08ec7fda63cfb6d458ad3bb10b31e4d"><div class="ttname"><a href="namespacequids.html#af08ec7fda63cfb6d458ad3bb10b31e4d">quids::simple_truncation</a></div><div class="ttdeci">bool simple_truncation</div><div class="ttdoc">simple truncation toggle - disable probabilistic truncation, increasing &quot;accuracy&quot; but reducing the r...</div><div class="ttdef"><b>Definition:</b> quids.hpp:69</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Pre-processor flags</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
proba. type</h3>
<p >The <code>PROBA_TYPE</code> flag is used to change the type used to represent probabilities and magnitude in the program. The default is <code>double</code> for a high enough precision, but other float type could be used to either get more precision or less memory/execution time cost.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
hash map overhead</h3>
<p >The <code>HASH_MAP_OVERHEAD</code> flag represent the overhead per element of the hashmap (of type <code>robin_hood::unordered_map</code>, default is set to <code>1.7</code> which has been determined through experiments).</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Global variables</h2>
<p >The default value of any of those variable can be altered at compilation, by passing an uppercase flag with the same name as the desired variable.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
align_byte_length</h3>
<p ><code>align_byte_length</code> represents the amount of byte to align objects to (default is <code>8</code>), and should be set to avoid missaligned memory access for objects that are "packed".</p>
<h3><a class="anchor" id="autotoc_md23"></a>
tolerance</h3>
<p ><code>tolerance</code> represents the minimum probability considered non-zero (default is <code>1e-30</code>, to compensate for numerical errors).</p>
<h3><a class="anchor" id="autotoc_md24"></a>
safety margin</h3>
<p ><code>safety_margin</code> represents the target proportion of memory to keep free (default is <code>0.1</code> for 10%).</p>
<h3><a class="anchor" id="autotoc_md25"></a>
simple truncation</h3>
<p ><code>simple_truncation</code> is a <code>bool</code> variable (default is <code>false</code>, but can be set to <code>true</code> by compilling with the <code>SIMPLE_TRUNCATION</code> flag). If <code>simple_truncation</code> is <code>true</code>, then truncation simply consist in selecting the n highest probability objects. Otherwise object are selected with some probabilistic aspect, with the probability of keeping an object being proportional to the probability of each object.</p>
<p >Probabilistic selctions cost a bit of time and of accuracy, with some gain in representation through an analog sampling process to a quantum Monte-Carlo algorithm.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
load balancing bucket per thread</h3>
<p ><code>load_balancing_bucket_per_thread</code> represent the number of partition par thread (or MPI node), which allows load balancing by then having a variable number of partition per thread according to each partition's size.</p>
<p ><code>load_balancing_bucket_per_thread</code> has a default of <code>8</code>.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
MPI global variables</h2>
<h3><a class="anchor" id="autotoc_md28"></a>
minimum equalize size, minimum equalize step and equalize imbalance.</h3>
<p ><code>mpi::min_equalize_size</code> represents the minimum per node average size required to automaticly call <code>equalize(...)</code> after a call to <code>quids::mpi::simulate(...)</code>.</p>
<p >If this first condition is met, <code>equalize(...)</code> if the maximum relative imbalance in the number of object accross the nodes is greater than <code>mpi::equalize_imablance</code>.</p>
<p >This loop will also stop if the improvment of inbalance was less the <code>mpi::min_equalize_step</code>, for which the default is <code>0.2</code>.</p>
<p ><code>mpi::min_equalize_size</code> is equal to <code>1000</code> by default, and <code>mpi::equalize_imablance</code> has a default of <code>0.1</code>.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
equalize children</h3>
<p >If <code>mpi::equalize_children</code> is <code>true</code> (default), equalizing is done by communicating objects to equalize the number of children. Otherwise if <code>false</code> the actual number of objects is balanced.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Utils global variables</h2>
<h3><a class="anchor" id="autotoc_md31"></a>
min vector size</h3>
<p ><code>utils::min_vector_size</code> represent the minimum size of any vector (the default is <code>100000</code>).</p>
<h3><a class="anchor" id="autotoc_md32"></a>
upsize policy</h3>
<p ><code>utils::upsize_policy</code> represent the multiplier applied when upsizing a vector (the default is <code>1.1</code>). It avoid frequent upsizing by giving a small margin.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
downsize policy</h3>
<p ><code>utils::downsize_policy</code> reprensent the threshold multiplier to downsize a vector (the default is <code>0.85</code>). A vector won't be downsized until the requested size is smaller than this ultiplier times the capacity of the given vector.</p>
<p ><b>!! this multiplier should always be smaller than the inverse of upsize_policy to avoid upsizing-downsizing loop !!</b> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
